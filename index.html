<!doctype html>
<html class="theme-next   use-motion ">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  
    <link href='//fonts.lug.ustc.edu.cn/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
  



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.4.5.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.2" />






<meta name="description" content="学习总结">
<meta property="og:type" content="website">
<meta property="og:title" content="aodiquan的博客">
<meta property="og:url" content="aodiquan.github.io/index.html">
<meta property="og:site_name" content="aodiquan的博客">
<meta property="og:description" content="学习总结">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aodiquan的博客">
<meta name="twitter:description" content="学习总结">



<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post',
    motion: true
  };
</script>

  <title> Hexo, NexT - aodiquan的博客 - 学习总结 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  






  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">aodiquan的博客</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">阿里嘎多</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
  <section id="posts" class="posts-expand">

    

    
    
      
      
        
        
        
      

      
    

    
      

  
  

  
  
  

  <article class="post post-type-读书笔记 " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/11/14/《征服c指针》笔记/" itemprop="url">
                  《征服c指针》笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            发表于
            <time itemprop="dateCreated" datetime="2015-11-14T23:05:50+08:00" content="2015-11-14">
              2015-11-14
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/11/14/《征服c指针》笔记/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/11/14/《征服c指针》笔记/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

        </div>
      </header>
    


    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody">
            
              <ol>
<li>C语言中数组和指针是完全不同的事物，但是因为有语法糖的存在，导致了数组和指针的混乱。</li>
<li>C语言中用宏定义变量或者函数的好处是在编译期间进行常量替换，从而提高运行效率；而且C的结构体不支持继承，可以用宏实现结构体中的共性部分。</li>
<li><p>表达式是指：</p>
<blockquote>
<ul>
<li>标识符（变量名、 函数名）。</li>
<li>常量（包括整数常量和浮点数常量）。</li>
<li>字符串常量（使用“”括起来的字符串）。</li>
<li>使用()括起来的表达式。</li>
<li>对表达式使用运算符，或通过运算符将表达式和表达式相互连接，这些表示方法也称为表达式，比如“5”、“hoge”都是表达式，则“5 + hoge”也是表达式。</li>
</ul>
</blockquote>
</li>
<li><p>左值：</p>
<blockquote>
<ul>
<li>作为变量，它有作为“自身的值”使用和作为“自身的内存区域”使用两种情况，比如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hoge=<span class="number">5</span>;</span><br><span class="line">hoge=<span class="number">10</span>;<span class="comment">//没问题</span></span><br><span class="line"><span class="number">5</span>=<span class="number">10</span>;<span class="comment">//非法</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>这种情况下，等号左边是自身的内存区域，右边是自身的值，像这样，表达式代表某处的内存区域的时候，我们称当前的表示式为左值（lvalue）；相对的是，表达式只是代表值的时候，我们称当前的表达式为右值。</p>
<ul>
<li>在C中，++hoge这样写法也是合法的，此时hoge是指某处的内存区域，虽然不符合左值的字面含义。</li>
</ul>
</li>
<li><p>间接引用（<strong>这个理解为解引用不如理解为解码更形象，将地址翻译为具体的值，类似于将一串没有意义的字符码按照规则解码为中文</strong>）：单目运算符*被称为间接引用运算符，运算符*将指针作为操作数，返回指针所指向的对象或者函数，只要不是返回函数，运算符*的结果都是<strong>左值</strong>，从运算符*的操作数的类型中仅仅去掉一个指针后的类型， 就是运算符*返回的表达式的类型-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/dec8362b-1dfb-4dfd-8aaf-5051cab4f322.jpg" alt=""><br><strong>个人理解，<code>int* a</code>（这样写就不迷惑了）定义的是一个变量<code>a</code>，<code>a</code>的类型是int类型的指针，这样是不能直接<code>a=1</code>的，传进来的是<code>&amp;a</code>即a的地址值，利用<code>*a</code>可以根据这个地址找到内存中的<code>a</code>，这个也就是main中的变量<code>a</code>所在的地址值，从而可以通过<code>*a=1</code>改变main中的a的值，所以定义的<code>int *a</code>和处于左值的<code>*a=1</code>是不一样的含义，比如如下代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">double</span> *b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">      *a = <span class="number">5</span>;<span class="comment">//*a通过间接引用获取到了main中的a值</span></span><br><span class="line">      *b = <span class="number">3.5</span>;</span><br><span class="line">      <span class="keyword">int</span> *c=a;<span class="comment">//如果需要定义新的指针来接收，就要这样，因为a是int类型的指针，而不是int *c=*a，注意一定要类型匹配，因为C没有类型推断的能力</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a;</span><br><span class="line">      <span class="keyword">double</span> b;</span><br><span class="line">      func(&amp;a, &amp;b) ;</span><br><span class="line">      <span class="built_in">printf</span>( <span class="string">" a. . %d b. . %f\n"</span> , a, b) ;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>之所以有多重*的存在，是因为比如二维数组，代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line">      <span class="comment">//下面都是同一个地址</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,*a);<span class="comment">//居然跟&amp;a[0]的结果一样</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,&amp;a);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,&amp;a[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,&amp;a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">      <span class="comment">//下面都是同一个地址</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,a[<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*(a+<span class="number">1</span>)+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//下面打印5,5</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,*(a[<span class="number">1</span>]+<span class="number">1</span>),*(*(a+<span class="number">1</span>)+<span class="number">1</span>));</span><br><span class="line">      <span class="comment">//下面打印0</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,**(&amp;a[<span class="number">0</span>]));</span><br><span class="line">      <span class="comment">//下面的前2个都是打印同一个地址，最后一个打印a[0][0]的值</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,&amp;a);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,(<span class="keyword">int</span>*)(&amp;a));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,*(<span class="keyword">int</span>*)(&amp;a));</span><br><span class="line">      <span class="comment">//打印所有元素</span></span><br><span class="line">      <span class="keyword">int</span> *p;</span><br><span class="line">      <span class="keyword">for</span>(p=a[<span class="number">0</span>];p&lt;a[<span class="number">0</span>]+<span class="number">12</span>;p++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,*p);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//下面打印1，即a[0][1]</span></span><br><span class="line">      <span class="keyword">int</span> *p=&amp;a;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,*p+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//下面打印4，即a[1][0]</span></span><br><span class="line">      <span class="comment">//~~这里即使再多加几个*，结果一样的，下面的*p+1直接取到最终结果，不关心定义的时候有几个*~~这里二维数组的例子不好，编译器干扰太多了，去看《再谈C语言指针》吧</span></span><br><span class="line">      <span class="comment">//这里就是我一直很困惑的地方，暂时理解为int *p=&amp;a取到的是a[0][0],如果再多一个*会向上取到a[0]，因为a[0]有个箭头指着a[0][0]，如果再多就没有意义了，因为没有谁引用a[0]</span></span><br><span class="line">      <span class="keyword">int</span> **p=&amp;a;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>,*p+<span class="number">1</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//关于*的取值问题，我又研究了一下（注意，不影响上面的*p直接取到最后结果的结论）</span></span><br><span class="line">      <span class="comment">//下面结果一样，都是一长串的地址，即&amp;a默认就是取a[0][0]的地址</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,&amp;a);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,&amp;a[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,&amp;a[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,*(&amp;a));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,*(&amp;a[<span class="number">0</span>]));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,**(&amp;a));</span><br><span class="line">      <span class="comment">//下面结果是0，这样看来虽然上面的结果是一样的，但是并不意味着需要*解引用的次数也一样，上面的结果估计是编译器在搞鬼，扰乱我的认知</span></span><br><span class="line">      <span class="comment">//***(&amp;a)个人理解是这样，*的优先级是从右向左，第一个*是解引用，第二个*是取到指针的指针即a[0]，第三个是取到a[0][0]</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,*(&amp;a[<span class="number">0</span>][<span class="number">0</span>]));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,**(&amp;a[<span class="number">0</span>]));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,***(&amp;a));<span class="comment">//*不能再多了，会报错invalid type argument of 'unary *'</span></span><br><span class="line">      <span class="comment">//下面结果是4</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,**(&amp;a[<span class="number">1</span>]));</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,*(*(*(&amp;a)+<span class="number">1</span>)));</span><br><span class="line">      <span class="comment">//下面结果是1</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d,"</span>,*(*(*(&amp;a))+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><del>注意<code>int *p=&amp;a;</code>和<code>int * *p=&amp;a;</code>取到不一样的指针-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/821b2eb9-3fa5-4631-a6c9-2426a14fba05.jpg" alt="">；</del><br>这里去看《再谈C语言指针—指向另一指针的指针》，图别信，画得不够形象;<br>如果是处于左值状态比如<code>int * *p=&amp;a;</code>可以有2个*，但是打印的时候即右值状态只能是1个*，即<code>printf(&quot;%d &quot;,*p+1);</code>不能写成<code>printf(&quot;%d &quot;,* *p+1);</code>，即使定义为<code>int * *p=&amp;a;</code>，因为只要1个*就取到最终值了；指针也可以指向函数-&gt;</strong><img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/cf463b69-a170-46af-8d97-4e4e0fd6165b.png" alt="">    <strong>*f两边的括号是必须的，不然<code>int *f(int*)</code>会被解读成<code>(int *) f(int*)</code>，以一个int*作为参数，并返回一个int*。</strong></p>
</li>
<li><p>地址运算符：单目运算符&amp;被称为地址运算符，<strong>&amp;将一个左值作为操作数，返回指向该左值的指针，对左值的类型加上一个指针， 就是&amp;运算符的返回类型</strong>-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/bc044a93-199a-492b-89f0-380ac6b55618.jpg" alt=""><br>另外，<strong>地址运算符不能将非左值的表达式作为操作数</strong>。</p>
</li>
<li><p>&amp;用于获取某个变量的地址值，比如<code>int hoge=5</code>，则<code>&amp;hoge</code>的值可能为<code>0xbfbfd9e4</code>；如果有<code>int *hoge_p;hoge_p = &amp;hoge;</code>，则有-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/c248f06d-4b05-4b5d-8a03-d03c86fd7453.jpg" alt="">，像这样，指针变量<code>hoge_p</code>保存了另外一个变量<code>hoge</code>的地址，我们认为“<code>hoge_p</code>指向<code>hoge</code>”，此外， 对<code>hoge</code>变量实施&amp;运算得到“<code>hoge</code>的地址”，有时候也称“<code>hoge</code>的地址”的值为“指向<code>hoge</code>的指针”（此时的“指针”指的是“指针类型的值”）；在指针前面加上*，可以表示指针指向的变量，因为<code>hoge_p</code>指向<code>hoge</code>，所以<code>*hoge_p</code>等同于<code>hoge</code>，一旦要求输出<code>*hoge_p</code>，就会输出<code>hoge</code>中保存的值5。</p>
</li>
<li><code>int *hoge_p;</code>似乎这里声明了一个名为<code>*hoge_p</code>的变量，而实际上，这里声明的变量是<code>hoge_p</code>，<code>hoge_p</code>的类型是“指向<code>int</code>的指针”；因为这种声明方式不太好理解，所以有人提出将*靠近类型这一侧进行书写，使其符合“<strong>类型 变量名</strong>”的形式-&gt;<code>int* hoge_p;</code>，但是在同时声明多个变量的情况下，比如<code>int* hoge_p, piyo_p;</code>容易误解定义了2个指针类型的变量，其实前者是指针，后者是int；</li>
<li>C有一个可以指向任何类型的指针类型<code>void*</code>，也可以像下面将<code>hoge_p</code>强制转换成<code>int</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> hoge = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">void</span> hoge_p;</span><br><span class="line">hoge_p = &amp;hoge;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*(<span class="keyword">int</span>*)hoge_p);</span><br><span class="line">```。</span><br><span class="line"> <span class="number">1.</span> 对指针加N，指针前进当前指针指向的数据类型的长度 × N，比如给一个`<span class="keyword">int</span>*`的变量加<span class="number">1</span>，地址会加<span class="number">4</span>，因为<span class="keyword">int</span>类型的长度是<span class="number">4</span>。</span><br><span class="line"> <span class="number">1.</span> c语言中字符串是使用“空字符”`\<span class="number">0</span>`来结束的，空字符的定义为“所有的位为<span class="number">0</span>的字节称为空字符”，也就是说，空字符是值为<span class="number">0</span>的字符，数据类型是<span class="keyword">int</span>*，当然如果是C++，就不是这个结论了；当常量<span class="number">0</span>处于应该作为指针使用的上下文中时，它就作为空指针使用，比如`<span class="keyword">int</span> *p = <span class="number">0</span>;`不警告，而`<span class="keyword">int</span> *p = <span class="number">3</span>;`会提出警告，但是这个原则并不是在所有情况下生效，不生效的情况：</span><br><span class="line"> &gt; 没有原型声明的函数的参数</span><br><span class="line"> &gt; 可变长参数函数中的可变部分的参数</span><br><span class="line"></span><br><span class="line"> 在这两个环境中需要通过使用宏定义<span class="literal">NULL</span>来将<span class="number">0</span>强制转型成<span class="keyword">void</span>*，可以显式地告之编译器当前的<span class="number">0</span>为指针*，以增强移植性-&gt;`<span class="preprocessor">#<span class="keyword">define</span> NULL ((void*)<span class="number">0</span>)`。</span></span><br><span class="line"> <span class="number">1.</span> 之所以从<span class="number">0</span>开始，是因为比如上班的公司位于名古屋的一座 <span class="number">5</span> 层的写字楼里，假设某人每爬一层楼花费 <span class="number">10</span> 秒钟， 那么此人如果从地面爬上 <span class="number">5</span> 楼，一共需要多少秒呢？<span class="number">50</span> 秒？恭喜你，答错了 ，答案是 <span class="number">40</span> 秒，相信大家在中学里都学过“等差数列”，等差数列第 _n_ 项等于“初项 ＋ 公差 × (_n_-<span class="number">1</span>)”，还有比如“<span class="number">1900</span> 年代”<span class="number">1</span>不是 <span class="number">19</span> 世纪，它的一大半属于 <span class="number">20</span> 世纪，更让人纠结的是，<span class="number">2000</span> 年不属于 <span class="number">21</span> 世纪，而属于 <span class="number">20</span> 世纪，对于这些现象， 如果</span><br><span class="line"> &gt; 写字楼和地面相同高度的那层，计数为 <span class="number">0</span> 层。</span><br><span class="line"> 数列最初的项，计数为 <span class="number">0</span> 项。</span><br><span class="line"> 最初的世纪计数为 <span class="number">0</span> 世纪，公历最初的年计数为 <span class="number">0</span> 年。</span><br><span class="line"></span><br><span class="line"> 就能够回避问题，还有如果需要要用一维数组去代替二维数组使用，可以这样</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* width 为行的宽度， 引用第 line 行， 第 col 列的元素*/</span></span><br><span class="line"><span class="built_in">array</span>[ line * width + col]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>假设最初的行为第 1 行， 最初的列为第 1 列， 并且数组的下标是从 1 开始， 就需要把上面的代码修改成下面这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">array</span>[ ( line-<span class="number">1</span>) * width + col]</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>数组：</p>
<blockquote>
<ul>
<li><strong>数组可以解读成“指向它的初始元素的指针”，尽管有三个小例外，但是这和在后面加不加[]没有关系</strong>，即对于<code>int* p</code>，<code>p=&amp;array[0];</code>等价于<code>p=array;</code>，<code>*(p + i)</code>等价于<code>p[i]</code>，<code>p[i]</code>只不过是<code>*(p + i)</code>的简便写法，所以可以将<em>(p + i)写成</em>(i + p)，也可以写成 i[p]，array[5]可以写成5[array]。</li>
<li>上面提到的3个小例外：</li>
<li><ul>
<li>如下代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> (*array_p)[<span class="number">3</span>];</span><br><span class="line">array_p = &amp;<span class="built_in">array</span>; <span class="comment">//←数组添加&amp;，取得“指向数组的指针”，没有问题的，因为类型相同</span></span><br><span class="line">array_p = <span class="built_in">array</span>;<span class="comment">//编译器提出警告，</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>提出警告原因是“指向int的指针”和“指向int的数组（元素个数3）的指针”是完全不同的数据类型，它们的不同之处是它们在做指针运算时结果不同，前者+1的时候移动4个字节，后者+1的时候，因为当前元素个数为3，因此会移动3*4个字节。</p>
<blockquote>
<ul>
<li><ul>
<li>对于<code>void func(int a[])</code>，因为在C中是不能够将数组作为函数的参数进行传递的，所以这里会被解读为<code>void func(int *a)</code>，就算定义了数组的元素个数也会被无视。</li>
</ul>
</li>
<li><p>[]运算符可以视为语法糖，因为<code>*(p + i)</code>这种写法解读困难。</p>
</li>
<li>大部分情况下[]可以替换指针的*，这样程序更加好理解，编译器会自动帮我们完成转换，效率一样，之所以学习指针是为了看懂指针的代码，除非是“一个巨大的char数组中，参杂了各种类型的数据，并且我们试图读取第多少字节的数据”这样的情况下（在网络通讯中，数据交换程序中经常会使用一个char数组保存各种数据类型的数据，我们通常将这种行为称为序列化），还是使用指针运算写的程序比较容易理解。</li>
<li>如果试图将数组作为函数参数进行传递，那就传递指向初始元素的指针，此时数组是引用传递，如果迫不得已需要复制数组实现值传递，可以将数组的所有元素整理成结构体的成员，但是如果这个数组很大，会存在效率的问题，这种情况是比如对下棋的决策树进行决策，不停地递归，这需要记录递归的每一步而不是引用传递覆盖原数据来比较出最优策略。</li>
<li>因为引用数组元素的时候，虽然可以写成a[i]，但是它只不过是*(a + i)的语法糖，因此c语言无法对数组下标越界进行检查，如果无论如何都需要进行数组长度检查，可以考虑将指针封装成结构体那样，运行时让指针自身持有可取值范围的信息，可是这么做对性能的影响很大，同时也丧失了非调试模式下编译后的库和指针的兼容性。</li>
</ul>
</blockquote>
</li>
<li><p>在如今的运行环境中，应用程序面对的是虚拟地址空间，多线程运行int i=1，很可能每个线程打印出来i的地址都是相同的，虚拟内存-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/ce247464-d55e-460e-93c7-ab6c29852667.jpg" alt=""></p>
</li>
<li><p>c语言的scanf()不是以行单位对输入内容进行解释，而是对连续字符流进行解释（换行字符也视为一个字符），scanf()连续地从流读入字符，并且对和格式说明符（比如%d）相匹配的部分进行变换处理，当格式说明符为%d的时候，输入<code>123↲</code>，从流中取得123部分的内容，并对它进行处理，换行符依旧会残留在流中，这样之后如果调用getchar()会接收到这个留下的换行符，而且当scanf()变换失败的时候（比如，指定了%d，但是输入的却是英文字符），scanf()会将失败的部分遗留在流中，在读入过程中有几个对象被成功地变换，scanf()的返回值就为几，这就导致一种情况，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;hoge) ! = <span class="number">1</span>)&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"输入错误，请再次输入！"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>一旦用户错误输入过一次，这段程序就会进入无限循环，原因就是错误输入的那部分字符串，将会被下一个scanf()读到，使用fgets和sscanf组合可以避免这种情况：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line"><span class="built_in">sscanf</span>(buf, <span class="string">"%d"</span>, &amp;xxx);</span><br></pre></td></tr></table></figure>
<ol>
<li><p>C 中有三种内存区域的寿命：</p>
<blockquote>
<ul>
<li>静态变量static修饰：寿命从程序运行时开始，到程序关闭时结束；静态变量总是在虚拟地址空间上占有固定的区域。</li>
<li>自动变量：寿命到声明该变量的语句块被执行结束为止；自动变量重复使用内存区域，因此自动变量的地址是不一定的，有可能使用相同的地址。</li>
<li>通过malloc()分配的领域：寿命到调用free()为止。</li>
</ul>
</blockquote>
</li>
<li><p>内存区域：</p>
<blockquote>
<ul>
<li>大多数操作系统都是将函数自身和字符串常量汇总配置在一个只读内存区域，因为函数本身不可能需要改写，以前有过函数本身也能变，但是太难看懂了，因此现代操作系统都禁用这种技术，如果执行程序是只读的，在同一份程序被同时启动多次的时候，通过在物理地址上共享程序能够节约物理内存，而且由于硬盘上已经存放了可执行程序，就算内存不足，也不需要将程序交换到虚拟内存，相反可以将程序直接从内存中销毁，Windows、UNIX等操作系统就是这样实现的，在一部分UNIX中，如果在程序运行的时候将该程序改写（再编译/连接等），当前运行的程序就会崩溃，在如今的处理环境中，经常会对程序加锁。</li>
</ul>
</blockquote>
</li>
<li><p>函数的指针：</p>
<blockquote>
<ul>
<li>如下代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func_p)(<span class="keyword">double</span>); <span class="comment">//←声明</span></span><br><span class="line">func_p = func; <span class="comment">//←将func 赋给func_p</span></span><br><span class="line">func_p(<span class="number">0.5</span>); <span class="comment">//←此时，func_p 等同于func</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>将“指向函数的指针”保存在变量中的技术经常被运用在如下场合：</p>
<blockquote>
<ul>
<li><ul>
<li>GUI 中的按钮控件记忆“当自身被按下的时候需要调用的函数”。</li>
</ul>
</li>
<li><ul>
<li>根据“指向函数的指针的数组”对处理进行分配。</li>
</ul>
<p>后者的“指向函数的指针的数组”，像下面这样使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func_table[])(<span class="keyword">double</span>) = &#123;</span><br><span class="line">    func0,</span><br><span class="line">    func1,</span><br><span class="line">    func2,</span><br><span class="line">    func3,</span><br><span class="line">&#125;;</span><br><span class="line">func_table[i](<span class="number">0.5</span>); <span class="comment">//←调用func_table[i]的函数，参数为0.5</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
</li>
</ol>
<p>使用上面的写法，不用写很长的switch case，只需通过i的值就可以对处理进行分配。</p>
<blockquote>
<ul>
<li>对于这个代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(**********<span class="built_in">printf</span>)(<span class="string">"hello, world\n"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p> 虽然对“指向函数的指针”使用解引用*，会让它暂时成为函数，但是因为在表达式中，所以它会被瞬间地变回成“指向函数的指针”，因此*有多少个都没有影响。</p>
<ol>
<li><p>函数调用：</p>
<blockquote>
<ul>
<li>概念图-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/31295579-8b52-44ea-b747-22e80b942369.jpg" alt="">。</li>
<li>C语言中，通常将自动变量保存在栈中，通过将自动变量分配在栈中，内存区域可以被重复利用，这样可以节约内存，而且将自动变量分配在栈中，对于递归调用也具有重要的意义。</li>
<li>对于如下代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c, d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    func(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>内存分布图-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/8af84749-b17b-42c8-a835-b34e71085a36.jpg" alt=""></p>
<ul>
<li>函数调用的实现总结：</li>
<li><ul>
<li>1. 在调用方，参数从后往前按顺序被堆积在栈中（Pascal 和Java是从前往后将参数堆积在栈中的，这种方式能够从前面开始对参数进行处理，所以对于程序员来说比较直观，这样处理后将参数从栈中除去是被调用方应该承担的工作，大部分情况下，这种方式的效率还是比较高的，C之所以采取和Pascal、Java相反的处理方式，是为了实现可变长参数这个功能）。</li>
</ul>
</li>
<li><ul>
<li>2. 和函数调用关联的返回信息也被堆积在栈中（对应于图 2-5的灰色部分），所谓的“返回地址”，是指函数处理完毕后应该返回的地址，正因为返回地址被堆积在栈中，所以无论函数从什么地方被调用，它都能返回到调用点的下一个处理。</li>
</ul>
</li>
<li><ul>
<li>3. 栈为当前函数所使用的自动变量增长提供所需大小的内存区域，1到4所增长的栈的区域成为当前函数的可引用区域。</li>
</ul>
</li>
<li><ul>
<li>4. 在函数的执行过程中，为了进行复杂的表达式运算，有时候会将计算过程中的值放在栈中。</li>
</ul>
</li>
<li><ul>
<li>5. 一旦函数调用结束，局部变量占用的内存区域就被释放。</li>
</ul>
</li>
<li>如果大范围地超过数组内存区域写入数据，内存中直到存储函数的返回信息的区域都有可能被破坏，导致函数无法返回，在C语言中，所谓将数组作为参数进行传递，只不过是传递指向数组初始元素的指针，作为被调用方，是完全不知道数组究竟有多长的，这对于没有做好数组长度检查的程序，存在安全漏洞，因为可以传递一个很大的数据，造成函数的返回地址被改写，让原来的程序运行任意的机器语言代码。</li>
<li>关于从后往前调用参数，比如<code>printf(&quot;%d, %s\n&quot;, 100, str);</code>，栈的状态如图-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/98fd9e88-382a-490f-bde8-2819ddca5017.jpg" alt="">，无论需要堆积多少个参数，总能找到第一个参数的地址，从图中可以看出，从printf()的局部变量来看，第一个参数（指向”%d, %s\n”的指针）一定存在于距离固定的场所，然后在printf()中， 通过对找到的第一个参数”%d, %s\n”进行解析，就可以知道后面还有几个参数，由于其余的参数是连续排列在第一个参数后面的，所以可以顺序地将它们取出，如果从前往后堆积参数，就肯定不能找到第一个参数（个人理解，可变参数意味着不确定，从后往前意味着开始不确定，但是可以知道什么时候传参结束，因为结束信号第一个参数是确定的，如果从前往后，开始可以确定，但是什么时候结束就没办法知道了）。</li>
</ul>
</li>
<li><p><code>malloc</code>：</p>
<blockquote>
<ul>
<li>像<code>malloc()</code>能够动态地（运行时）进行内存分配，并且可以通过<code>free()</code>以任意的顺序释放的记忆区域，称为堆（heap）。</li>
<li>malloc()的返回值的类型为<code>void*</code>。</li>
<li>malloc()大体的实现是，从操作系统一次性地取得比较大的内存，然后将这些内存“零售”给应用程序，根据操作系统的不同，从操作系统取得内存的手段也是不一样的，比如在UNIX的情况下使用brk()*的系统调用（brk是break的简写），现实中为了内存的效率做了很多优化，考虑最简单的情况（想了解具体的还是得去看操作系统），使用链表管理内存-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/ed96abdd-6c6c-4cdb-ac52-7c0a0e46881a.jpg" alt="">，malloc()遍历链表寻找空的块，如果发现尺寸大小能够满足使用的块，就分割出来将其变成使用中的块，并且向应用程序返回紧邻管理区域的后面区域的地址，free()将管理区域的标记改写成“空块”，顺便也将上下空的块合并成一个块，这样可以防止块的碎片化，在这种内存管理方式的运行环境中，一旦数组越界检查发生错误，越过malloc()分配的内存区域写入了数据，将会破坏下一个块的管理区域，以后的malloc()和free()调用中出现程序崩溃的几率会非常高（因为管理区域数据错乱就找不到链表的下一个元素了）。</li>
</ul>
</blockquote>
</li>
<li><p>调用<code>free()</code>之后，对应的内存区域是不会立刻返还给操作系统的，而是随着某次malloc()调用，恰好将这片区域重新进行分配后，才会发生这部分内容的改写，这就带来一个问题，当某块区域同时被A、B引用时，A认为不需要了，free掉，但是B依然可以访问到，容易出现bug（这就是所谓的不安全，java有虚拟机帮我们管理就不用考虑这些了），解决方法是封装<code>free()</code>，在区域被释放之前故意将区域破坏（比如可以胡乱地填充一个像<code>0xCC</code>这样的值） ，另外因为无法知道当前指针指向的区域的大小（C没有提供公开内存大小的函数），可以对malloc()也进行封装，每次分配内存的时候多留出一点空间，然后在最前面的部分记录区域的大小信息。</p>
</li>
<li>C语言默认地将没有声明的函数的返回值解释成<code>int*</code>类型，那些运气好、目前还能跑起来的程序，如果被迁移到int和指针长度不同的处理环境中，就会突然跑不动了。</li>
<li><code>hoge-&gt;piyo</code>是<code>(*hoge).piyo</code>的语法糖，利用<em>p的</em>，从指针p获得结构体的实体，然后引用成员hoge，所以又可以写成<code>hoge^.piyo</code>。</li>
<li><p>多维数组：</p>
<blockquote>
<ul>
<li>C不存在多维数组，看上去像多维数组的数组，其实是“数组的数组”，比如对于<code>int hoge[3][2];</code>，可以通过hoge[i][j]的方式去访问，此时hoge[i]是指“int的数组（元素个数2）的数组（元素个数3） ”中的第i个元素，其类型为“int 数组（元素个数2）”， 因为是在表达式中，所以在此时此刻，hoge[i]也可以被解读成“指向int的指针。</li>
<li>如果试图将<code>int的数组</code>作为参数传递给函数，可以直接传递<code>指向int的指针</code>，因为在表达式中，数组可以解释成指针，对于<code>int的数组（元素个数2）的数组（元素个数3）</code>，对于<code>数组（元素个数3）</code>部分，在表达式中可以解释成指针，所以可以向函数传递<code>指向int的数组（元素个数2）的指针</code>，即可以用比如<code>void func(int (*hoge)[2]);</code>来接收，这个是<code>void func(int hoge[3][2]);</code>和<code>void func(int hoge[][2]);</code>的语法糖。</li>
<li>java和C一样不存在多维数组，也是使用数组的数组来实现多维数组，但是，Java和C不同的是，Java的数组都是指针，所以所谓的“数组的数组”其实是“指向数组的指针的数组”，比如java代码<code>double[][] polyline = new int[nPoints][2];</code>，对应的内存中的分配-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/a5f09fe7-4551-45e1-af47-e343d68f5930.jpg" alt=""></li>
</ul>
</blockquote>
</li>
<li><p>对指向函数类型的指针不能做指针运算， 因为无法得到当前指针类型的大小。</p>
</li>
<li><p>结构体和共用体：</p>
<blockquote>
<ul>
<li>在语法上，结构体和共用体是作为派生类型使用的，但是在声明中和数据类型修饰符（也就是int、double等）处于相同的位置。</li>
<li>只有派生指针、数组和函数的时候，类型才可以通过一维链表表示，结构体、共用体派生类型只能用树结构进行表现。</li>
<li>结构体类型可以集合几个其他不同的类型，而数组只能线性地包含同一个类型。</li>
<li>共用体的语法和结构体相似，但是结构体的成员是“排列地”分配在内存中，而共用体的成员则是“重叠地”分配在内存中。（结构体的排列遵循内存对齐，而共用体的各个成员是以同一个地址开始存放的，每一个时刻只可以存储一个成员，这样就要求它在分配内存单元时候要满足两点:</li>
<li><ul>
<li>1.一般而言,共用体类型实际占用存储空间为其最长的成员所占的存储空间。</li>
</ul>
</li>
<li><ul>
<li>2.若是该最长的存储空间对其他成员的元类型(如果是数组,取其类型的数据长度,例<code>int a[5]</code>为4)不满足整除关系,该最大空间自动延伸，如下代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">union</span> sample</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">short</span> <span class="keyword">int</span> n;<span class="comment">//长度2</span></span><br><span class="line"> <span class="keyword">char</span> c[<span class="number">10</span>];<span class="comment">//长度10</span></span><br><span class="line"> <span class="keyword">float</span> f;<span class="comment">//长度4</span></span><br><span class="line">&#125;s;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</blockquote>
<p>本来sample的空间应该是sizeof(char)*10=10，但是如果只是10个单元的话，那可以存几个float型(4位)呢?两个半?当然不可以,所以sample的空间延伸为既要大于10,又要满足其他成员所需空间的整数倍,即12，所以union的存储空间先看它的成员中哪个占的空间最大,拿他与其他成员的元长度比较,如果可以整除,ok,否则,找第一个能被整除的数。</p>
<ul>
<li>结构体相当于java中的类，因此在C中定义链表的代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> Word_tag &#123;</span><br><span class="line">      <span class="keyword">char</span> *name;</span><br><span class="line">      <span class="keyword">int</span> count;</span><br><span class="line">      <span class="keyword">struct</span> Word_tag _next;</span><br><span class="line">&#125;Word;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>跟java中类似。</p>
</li>
<li><p>使用const修饰符（变量名），只意味着使其“只读”，只读的体现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> dest, <span class="keyword">const</span> <span class="keyword">char</span> src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        src = <span class="literal">NULL</span>; <span class="comment">//编译器没有报错，可以修改src的值</span></span><br><span class="line">        *src = <span class="string">'a'</span> ; <span class="comment">//错误！成为只读的不是src，而是src所指向的对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果需要将src自身定义为只读，可以写成下面这样：</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> dest, <span class="keyword">char</span> <span class="keyword">const</span> src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        src = <span class="literal">NULL</span>; <span class="comment">//错误！src为只读，不可更改</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果将src和src指向的对象都定义为只读，可以写成下面这样：</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">my_strcpy</span><span class="params">(<span class="keyword">char</span> dest, <span class="keyword">const</span> <span class="keyword">char</span> <span class="keyword">const</span> src)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">        src = <span class="literal">NULL</span>;<span class="comment">//错误！</span></span><br><span class="line">        *src = <span class="string">'a'</span>;<span class="comment">//错误！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这跟java final的效果一样。</p>
<ol>
<li>typedef 用于给某类型定义别名，比如<code>typedef char *String;</code>，通过以上的声明，以后对于“指向char的指针”可以使用<code>String</code>这个别名。</li>
<li><p>C中如果初始化的时候可以确定元素个数，[]可以置空：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">3</span>] = &#123; <span class="comment">/* int a[3][3]的省略形式*/</span></span><br><span class="line">     &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">     &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">     &#123;<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其余的元素被初始化为0。</p>
</li>
<li><p>字符串常量</p>
<blockquote>
<ul>
<li>使用””包围起来的字符串被称为字符串常量，字符串常量的类型是“char的数组”。</li>
<li>在表达式中，它可以解读为指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">str = <span class="string">"abc"</span>;<span class="comment">//可以将指向"abc"的初始元素的指针赋给str</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>char数组的初始化是个例外，此时的字符串常量，作为在花括号中分开书写的初始化表达式的省略形式，编译器会进行特殊处理，即<br><code>char str[] = &quot;abc&quot;;</code>   和<br><code>char str[] = {&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;\0&#39;};</code>具有相同的含义，也可以这样定义：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p>这样定义不是初始化char的数组，而是初始化指针，此时的“abc”就是普通的“char的数组”，在表达式中被解释成“指向char的指针”，然后被赋给str；但是依然不能修改”abc”这个字符串常量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[<span class="number">0</span>] = <span class="string">'d'</span>; <span class="comment">//在大部分的处理环境中会报错！</span></span><br></pre></td></tr></table></figure></p>
<p>注意如下的写法是非法的，因为编译器不会进行特殊处理：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">4</span>];</span><br><span class="line">str = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>C 声明读法（比如标准库中有一个 signal()函数，它的原型声明是<code>void (*signal(int sig, void (*func) (int) ) ) (int) ;</code>）：</p>
<blockquote>
<ul>
<li>1. 首先着眼于标识符。<br>void ( <strong>*signal</strong>( int sig, void ( *func) ( int) ) ) ( int) ;<br>英语的表达为 ：<br>signal is</li>
<li>2. 相比<strong>*</strong>， <strong>()</strong>的优先顺序更高 ，所以先解释这部 分。<br>void ( <strong><em>signal(int sig, void (</em>func) (int) )</strong> ) ( int) ;<br>英语的表达为 ：<br>signal is function() returning</li>
<li>3. 解释参数部分。这里有两个参数，第一参数是<strong>int sig</strong>。<br>void ( <em>signal( <strong>int sig</strong>, void ( </em>func) ( int) ) ) ( int) ;<br>英语的表达为 ：<br>signal is function(sig is int,) returning</li>
<li>4. 着眼另外一个参数。<br>void ( <em>signal( int sig, void ( **</em>func**) ( int) ) ) ( int) ;<br>英语的表达为 ：<br>signal is function(sig is int, func is) returning</li>
<li>5. 因为有括号，所以这里解释 <strong>*</strong>。<br>void ( <em>signal( int sig, void **(</em>func)** ( int) ) ) ( int) ;<br>英语的表达为 ：<br>signal is function(sig is int, func is pointer to) returning</li>
<li>6. 解释表示函数的<strong>()</strong>，参数为<strong>int</strong>。<br>void ( <em>signal( int sig, void **(</em>func) (int) )** ) ( int) ;<br>英语的表达为 ：<br>signal is function(sig is int, func is pointer to function(int) returning) returning</li>
<li>7. 解释数据类型修饰符 <strong>void</strong>。<br>void ( <em>signal( int sig, **void (</em>func) (int) )** ) ( int) ;<br>英语的表达为 ：<br>signal is function(sig is int, func is pointer to function(int) returning void)<br>returning</li>
<li>8. 参数部分已经解释结束。接着因为有括号，所以这里解释 <strong>*</strong>。<br>void <strong>(<em>signal(int sig, void (</em>func) (int) ) )</strong> ( int) ;<br>英语的表达为 ：<br>signal is function(sig is int, func is pointer to function(int) returning void)<br>returning pointer to</li>
<li>9. 解释表示函数的<strong>()</strong>，参数为<strong>int</strong>。<br>void <strong>(<em>signal(int sig, void (</em>func) (int) ) ) (int)</strong> ;<br>英语的表达为 ：<br>signal is function(sig is int, func is pointer to function(int) returning void)<br>returning pointer to function(int) returning</li>
<li>10. 最后，添上<strong>void</strong>。<br><strong>void (<em>signal(int sig, void (</em>func) (int) ) ) (int)</strong> ;<br>英语的表达为 ：<br>signal is function(sig is int, func is pointer to function(int) returning void)<br>returning pointer to function(int) returning void</li>
<li>11. 翻译成中文<strong>……</strong><br><strong>signal</strong>是返回<strong>“</strong>指向返回<strong>void</strong>参数为<strong>int</strong>的函数的 指针 <strong>”</strong>的函数，它有两个参数，一个是<strong>int</strong>，另一个是<strong>“</strong>指向返回 <strong>void</strong> 参数为 <strong>int</strong> 的函数的指针 <strong>”</strong></li>
</ul>
</blockquote>
</li>
<li><p>C可以改变数组长度，通过使用malloc()在运行时再为数组申请必要的内存区域，实现变长数组，而java无法实现，只能通过虚拟机拷贝然后new一个新的出来，旧的被垃圾回收。</p>
</li>
<li><p>C的main可以这样定义<code>int main(int argc, char *argv[])</code>（注意这里[]是*的语法糖，因此相当于**argv），这种方式可以取得命令行的参数，比如UNIX中的<code>cat</code>命令，<code>cat -a hoge.txt piyo.txt</code>的效果是打开2个文件，结合起来输出，此时argv在内存中的结构-&gt;<img src="a26a42c2-4e9e-4c40-8276-0cbcfe0b0f92_128_files/93903f41-55a2-4555-822a-b148ae3e695a.jpg" alt=""><br>这个**argv，是一个指向指针的指针，用来将命令行参数保存下来，因为cat、-a等的长度不确定，所以需要一个指针来引用他们，而hoge.txt、piyo.txt这几个参数也是不定的，所以又需要有一个指针来引用，最后就需要二维指针了。</p>
</li>
<li><p>回调函数是一个程序员不能显式调用的函数，通过将回调函数的地址传给调用者从而实现调用。</p>
</li>
<li><p>c/c++的引用，它跟java的引用完全不是一个东西，c/c++的引用是同一块内存的不同名字，而java的引用是指向一个对象，引用本身也占用了内存，列举一下c/c++能对指针进行的一些常见操作：</p>
<blockquote>
<p>1、指向一个对象,如<code>Person *p = new Person….；int *iv = new int…</code>。<br>2、对指针所指的对象进行操作：<code>P-&gt;getAge();</code>           <code>(*p).getAge();</code>。<br>3、获取存储在指针中的地址值。<br>4、将指针指向另外一个对象：<code>Person *p1 = new Person…; p = p1;</code>，但不可以*p = p1这样来赋值。<br>5、删除new的空间，<code>delete p1;</code>。<br>6、其它诸多操作。</p>
</blockquote>
<p>这么多已经足够了，接下来看看java引用能做什么操作：</p>
<blockquote>
<p>a、指向一个对象，如<code>Person p = new Person…</code>。<br>b、调用对象的方法，<code>p.getAge();</code>。<br>c、指向另外一个对象，<code>Person p1 = new Person…; p = p1;</code>。</p>
</blockquote>
<p>对于a和1，他们的功能是类似的，但java引用无法指向一个基本变量；对于b，java引用和指针就不同了，在这点上，java reference更像是解引用（dereference）了的指针，或者说java中的<code>.</code>操作符某种程度上等价于指针的-&gt;操作符，如果是这样种解释的话，我们无法再对java的reference解引用了；对于c和4，是类似的。</p>
</li>
<li>i++和++i的区别（同样适用于java）：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//++i</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> ++ (<span class="keyword">int</span> &amp;i)&#123;</span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i++</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">operator</span> ++ (<span class="keyword">int</span> &amp;i)&#123;</span><br><span class="line">  <span class="keyword">int</span> j = i;</span><br><span class="line">  i = i + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> j;<span class="comment">//因为返回的j依然是i的旧值，所以跟返回值有关的会有延迟，但是如果跟i有关的会立即拿到新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

            
          </span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  


        </div>

        


        

      </div>

      
        
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/My_Pictrue/touXiang.png" alt="myh" itemprop="image"/>
          <p class="site-author-name" itemprop="name">myh</p>
        </div>
        <p class="site-description motion-element" itemprop="description">学习总结</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">1</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/aodiquan" target="_blank">
                  
                    <i class="fa fa-globe"></i> github
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


      
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">myh</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"myh007"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     


    
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.2"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.2"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
<script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

<script type="text/javascript" src="/js/motion.js?v=0.4.5.2" id="motion.global"></script>


  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  

  <script type="text/javascript" src="/js/bootstrap.js"></script>

  
  
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
  </script>

  <script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for (i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  </script>

  
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/MathJax.js"></script>
    <script type="text/javascript" src="http://cdn.staticfile.org/mathjax/2.4.0/config/TeX-AMS-MML_HTMLorMML.js"></script>
  


  
  

</body>
</html>
